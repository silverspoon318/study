## 왜 Flux를 바꿔야 하나?
Redux는 Flux가 해결하는 문제점에다가 추가적인 문제점을 더 해결할 수 있다.

[Redux로의 카툰 안내서](http://bestalign.github.io/2015/10/26/cartoon-intro-to-redux/)

1. 스토어의 코드는 애플리케이션 상태를 삭제하지 않고는 리로딩(reloading)이 불가능하다.
스토어(store)는 다음의 두 가지를 포함한다.
- 상태 변환을 위한 로직
- 현재 애플리케이션 상태

스토어 객체 하나가 이 두 가지를 가지고 있는 것은 핫 리로딩을 할 때 문제점을 만든다.
새로운 상태 변환 로직(state change logic)을 위해 스토어 객체를 리로딩하면 스토어에 저장되어있는 기존의 상태의 상태까지 잃어버리는 데다가
스토어와 시스템의 나머지 부분 사이에 있는 이벤트 구독(event subscription) 까지 망가져 버린다.

- 해결방법 : 두 기능을 분리하자. 한 한객체는 어플리케이션 상태만을 가지게 하고, 이 객체는 리로딩하지 않도록 하자.
             또 다른 객체는 모든 상태 변환 로직을 가지도록 하자. 이 객체는 상태를 가지고 있지 않으므로 걱정없이 리로딩 할 수 있을 것이다.

2. 애플리케이션 상태는 매 액션마다 재기록한다.
시간 여행 디버깅을 위해서는 상태 객체의 모든 버전들을 기록해두어야 한다. 그걸 가지고 쉽게 이전 상태로 돌아갈 수 있다.

매번 상태가 새로 바뀔 때마다 이전 애플리케이션 상태를 상태 객체의 버전들을 저장하는 배열에 추가할 필요가 있다.
하지만 JavaScript의 동작 방식 때문에 단순히 상태를 가진 변수를 배열에다가 추가하는 것만으로는 부족하다. 이 방식으로는 애플리케이션 상태의
스냅샷(snapshot)을 생성하는게 아니라 같은 객체를 가리키는 새로운 포인터(pointer)를 만들 뿐이다.

제대로 동작하게 만들기 위해서는 각각의 버전이 완벽히 독린된 객체가 될 필요가 있다. 그러면 이전 상태들이 실수로 수정되는 일은 일어나지 않을 것이다.

- 해결방법 : 액션이 스토어로 전달되었을 때 기존의 애플리케이션 상태를 수정하는 대신, 그 상태를 복사한 뒤 복사본을 수정하면 된다.

3. 서드파티 플러그인(third-party plugin)이 들어갈 좋은 장소가 없다.
개발자 도구는 여러 곳에 쉽게 쓰일 수 있도록 만들어야 한다. 사용자는 자신의 코드를 수정하지 않고도 간단히 코드 몇줄을 집어넣는 것만으로 개발자 도구를
사용할 수 있어야 한다.

이렇게 하기 위해서는 기존의 코드에 서드파티 플러그인을 추가할 수 있는 장소인 확장점(extension point)이 필요하다.

관련 예제로 로깅(logging)이 있다. 매 액션마다 consolog.log()를 실행한다고 가정해보면, 액션이 들어왔을 때 그 액션의 결과로서 만들어지는 새로운 상태를 로깅할 것이다.
Flux에서는 디스패쳐(dispatcher)의 업데이트와 각 스토어의 업데이트를 구독(subscribe)해야만 한다. 하지만 이것은 서드파티 모듈(third-party module)이 쉽게 할 수 있는 것이 아니다.

- 해결방법 : 시스템의 부분을 다른 객체들로 쉽게 감쌀 수 있게 만들어보자.
            이 객체들은 약간의 추가 기능들을 시스템의 부분에 추가한다. 이런 확장점(extension point)을 "enhancer" 또는 "higher order" 객체 혹은 미들웨어(middleware)라고 부른다는 것을
            알 수 있다. 또한 상태변환 로직(state change logic)을 트리를 사용해서 구조화하자. 상태가 변했다는 것을 뷰에게 알리기 위해 스토어는 단 하나의 이벤트만 보내면 될 것이다.
            이 이벤트는 모든 상태 트리가 처리 된 뒤에 보낸다.
