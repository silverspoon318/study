## Q. 멍청하고 똑똑하다니 그게 뭔뜻이죠?
물론 실제로 멍청하거나 똑똑한건 아니고.. 추상적인 의미입니다. 이는 리액트 프로젝트에서 사용하면 유용한 패턴인데요, 조금 더 제대로 된 표현으로 쓰자면, 이 패턴에선 컴포넌트들이 presentational (멍청한) 컴포넌트와 container (똑똑한) 컴포넌트로 분류됩니다.
멍청한 컴포넌트들은 오직, props 로 전달받은 값을 렌더링하는것을 목표로 합니다. 이 컴포넌트들은 자신들만의 CSS 스타일을 가지고 있을 수 있구요, state 를 갖고있지 않습니다. 뭔가 처리를 해야 할 때는, 똑똑한 컴포넌트에서 선언된 함수를 props 로 전달받아서 실행합니다.
반대로 똑똑한 컴포넌트는 멍청한 컴포넌트들을 관리하는 녀석입니다. state 를 지닐 수 있고, 작업을 프로세싱 할 수 있죠. 그리고 기본적인 틀을 갖추기 위한 CSS 스타일만을 가지고있고, 복잡한 스타일을 갖고있지 않습니다.
이렇게 컴포넌트를 분류하면, 데이터의 흐름이 간편해진답니다. 추가적으로 컴포넌트의 재사용률도 높여주죠.

## Q. 엥? 컴포넌트가 함수형태로 선언이 되어있네요?
import React from 'react';
import './Header.css';

const Header = () => (
    <div className="Header">
        POSTS
    </div>
)

export default Header;

독자분들중 일부분은 이런 코드를 처음 보시는 분들도 계실 수 있습니다. (특히.. 제 블로그만 보고 리액트를 공부하신분이라면요.. 아직 블로그에서 이 내용을 다룬적이 없습니다. 조만간 내용을 업데이트 할 때 다루게 될 것 같군요) 이런 형식으로 선언된 컴포넌트는 함수형 컴포넌트 (Functional Component) 라고 부릅니다. 만약에 state 가 없고, life cycle 메소드가 필요없는 멍청한 컴포넌트라면, 함수형 컴포넌트로 선언을 하는것이 좋은 패턴입니다. 보기에도 깔끔하고, 컴포넌트의 로직을 컴포넌트 바깥으로 옮기므로, 나중에 테스팅하기에도 편하죠.
함수형 컴포넌트는 this 에 접근하는것이 불가능하며, lifeCycle api 들을 사용하는것이 불가능합니다.
함수형 컴포넌트는 오직 전달받는 props 에만 의존합니다. props 는 어떻게 전달받는지 볼까요?
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
ES6 의 destructure 기능을 사용하면 다음과 같이 선언 할 수 있습니다.
function Welcome({ name }) {
  return <h1>Hello, {name}</h1>;
}
꽤 편하죠? 앞으로 멍청한 컴포넌트를 선언할때는 이 문법이 계속해서 사용 될 것입니다.
